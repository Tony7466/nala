#                 __
#    ____ _____  |  | _____
#   /    \\__  \ |  | \__  \
#  |   |  \/ __ \|  |__/ __ \_
#  |___|  (____  /____(____  /
#       \/     \/          \/
#
# Copyright (C) 2021, 2022 Blake Lee
#
# This file is part of nala
#
# nala is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# nala is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with nala.  If not, see <https://www.gnu.org/licenses/>.
"""The Repo Module for Nala's Local Repository Management."""
from __future__ import annotations

import hashlib
import os
from dataclasses import dataclass, field
from datetime import datetime, timezone
from gzip import compress
from pathlib import Path
from subprocess import run
from typing import Generator

import apt_pkg
import typer
from apt import Version

from nala import _
from nala.cache import Cache
from nala.constants import SOURCEPARTS
from nala.downloader import versions_to_urls
from nala.options import DEBUG, VERBOSE, nala
from nala.utils import vprint

REPO_PATH = Path("/var/cache/nala/repo")
REPO_GPG = REPO_PATH / ".gnupg"
NALA_KEY = REPO_PATH / "nala-key.gpg"
NALA_PRIVATE_KEY = REPO_PATH / "private.gpg"
PACKAGE_FILE = REPO_PATH / "Packages"
RELEASE_FILE = REPO_PATH / "Release"
REPO_SOURCES = SOURCEPARTS / "nala-repo.list"


def hash_file(path: Path) -> bool:
	"""Check hash value."""
	md5 = hashlib.new("md5")
	sha256 = hashlib.new("sha256")
	filesize = 0
	with path.open("rb") as file:
		while data := file.read(4096):
			md5.update(data)
			sha256.update(data)
			filesize += len(data)

	return md5.hexdigest(), sha256.hexdigest(), filesize


def hash_bytes(data: bytes) -> bool:
	"""Check hash value."""
	md5 = hashlib.new("md5")
	sha256 = hashlib.new("sha256")

	md5.update(data)
	sha256.update(data)
	filesize = len(data)

	return md5.hexdigest(), sha256.hexdigest(), filesize


@dataclass(unsafe_hash=True)
class RepoFile:
	data: bytes = field(hash=False)
	md5: str = field(hash=False)
	sha256: str = field(hash=True)
	size: int = field(hash=False)
	path: Path = field(hash=False)


class Repo:
	def __init__(self) -> None:
		self.origin = "Nala"
		self.label = "Nala"
		self.suite = "cache"
		self.codename = "cache"
		# https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
		# Wed, 14 Sep 2022 19:49:53 +0000
		# Probably Make this dependent on the arches inside the repo just to be safe.
		self.arches: list[str] = apt_pkg.get_architectures()
		# Key will be plain file, and value will be compressed version
		self.repo_files: dict[RepoFile, RepoFile] = {}
		self.components = "main"
		self.description = "Generated by Nala"

	@staticmethod
	def rfc_date() -> str:
		"""Return RFC 5322 formatted string of the current time UTC.

		Example: Wed, 14 Sep 2022 19:49:53 +0000
		"""
		# https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
		return datetime.now(timezone.utc).strftime("%a, %d %b %Y %X %z")

	def write_repo_files(self) -> None:
		"""Write the repository files to disk."""
		for file in self.all_files():
			file.path.write_bytes(file.data)
		RELEASE_FILE.write_text(self.format_release())
		REPO_SOURCES.write_text(
			"# This is a local repository cache for Nala. This gives you a finer control over your history.\n"
			"# It is believed that this could be the path to supporting proper rollbacks for upgrades.\n"
			f"deb [signed-by={NALA_KEY}] file:{REPO_PATH} ./\n"
		)

	def all_files(self) -> Generator[RepoFile, None, None]:
		"""Iterate both plain and compressed RepoFiles."""
		yield from self.repo_files.keys()
		yield from self.repo_files.values()

	def gen_package_file(self) -> None:
		"""Generate the package file's data."""
		pkg_data = run(
			["dpkg-scanpackages", REPO_PATH],
			capture_output=True,
		).stdout

		cmp_data = compress(pkg_data)

		self.repo_files[
			RepoFile(pkg_data, *hash_bytes(pkg_data), PACKAGE_FILE)
		] = RepoFile(cmp_data, *hash_bytes(cmp_data), PACKAGE_FILE.with_suffix(".gz"))

	def format_release(self) -> str:
		"""Return the release file as a string."""
		release = [
			"Origin: Nala",
			"Label: Nala",
			"Suite: cache",
			"Codename: cache",
			f"Date: {self.rfc_date()}",
			# Probably Determine the arches based on the packages that are in the repo?
			"Architectures: all amd64 arm64 armel armhf i386 mips64el mipsel ppc64el s390x",
			"Components: main",
			"Description: Generated by Nala",
		]

		# Generate the Checksum blocks
		md5sum = ["MD5SUM:"]
		sha256 = ["SHA256:"]
		for file in self.all_files():
			sha256.append(f" {file.sha256}    {file.size} {file.path.name}")
			md5sum.append(f" {file.md5}    {file.size} {file.path.name}")
		release.extend(sha256)
		release.extend(md5sum)
		return "\n".join(release) + "\n"

	def parse_packages(self) -> None:
		"""Parse packages from the Packages file."""
		self.pkgs: list[dict[str, str]] = []

		# This will only iterate over the keys which are uncompressed
		for repofile in self.repo_files:
			for package in repofile.data.decode().split("\n\n"):
				pkg = {}
				# Each iteration is one line in the package definition
				for line in package.splitlines():
					# Line starting with a space is extra data for the current key
					if line.startswith(" "):
						# Update the map with the extra value data
						# Preserve original formatting by keeping the new line
						pkg[key] += f"\n{line}"
						continue

					# Extract the Key and Value
					# This means we have hit a new key
					key, value = line.split(": ", 1)

					# Add the key and value to our map
					pkg[key] = value

				# Do not add empty package definitions.
				if not pkg:
					continue

				self.pkgs.append(pkg)


def gpg(command: list[str]) -> None:
	"""Run GPG batch mode always accepting yes."""
	gpg = "gpg --yes --batch".split()
	run(gpg + command, capture_output=True, check=True)


def sign_release(force: bool) -> None:
	"""Sign the release file as InRelease."""
	REPO_GPG.mkdir(mode=0o600, exist_ok=True)
	os.environ["GNUPGHOME"] = f"{REPO_GPG}"

	if not NALA_PRIVATE_KEY.is_file() or force:
		# Create a New Key
		gpg("--passphrase --quick-generate-key nala-key".split())
		# Export the public key so it can be used
		gpg(f"-o {NALA_KEY} --export nala-key".split())

	# Clearsign the Release file
	gpg(
		f"--clearsign --digest-algo SHA512 -o {REPO_PATH / 'InRelease'} {REPO_PATH / 'Release'}".split()
	)

	# Finally remove our gpg working directory
	# Going to just hide this for a while. Think about an option.
	# run(f"rm -rf {REPO_GPG}".split(), capture_output=True)


@nala.command(help=_("I beg, pls moo"))
def repo(
	only_print: bool = typer.Option(
		False, "--only-print", help="Only Print the Information Nala would write."
	),
	debug: bool = DEBUG,
	verbose: bool = VERBOSE,
	# man_help: bool = MAN_HELP,
) -> None:
	"""Nala repo."""
	# Dump any debs into this directory
	# TODO: Needs sudo check
	# PermissionError: [Errno 13] Permission denied: '/var/cache/nala'
	vprint(f"Checking {REPO_PATH}")
	REPO_PATH.mkdir(parents=True, exist_ok=True)

	repo = Repo()
	vprint("Generating Package Files")
	repo.gen_package_file()
	vprint("Parsing Packages")
	repo.parse_packages()

	vprint("Writing Repo Files")
	repo.write_repo_files()

	vprint("Signing Release")
	sign_release(force=True)
